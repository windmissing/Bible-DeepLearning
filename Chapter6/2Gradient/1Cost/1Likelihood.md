<!--sec data-title="something" data-id="section0" data-show=false ces-->

大多数神经网络使用[最大似然估计](https://windmising.gitbook.io/mathematics-basic-for-ml/gai-shuai-lun/likelihood)来训练，由此推导出来的代价函数为：  
$$
J(\theta) = -E_{X,y \sim \hat P_{data}}\log p_{model}(y|x)
$$

使用这种代价函数的优点是：  
1. 不用为每个模型设计代价函数，p(y|x)定了代价函数就这了。  
2. log的形式可以消除某些单元的指数效果，避免神经元饱和。  
3. [?]应用于实践中时通常没有最小值

<!--endsec-->

# 使用最大似然导出代价函数  

大多数现代的神经网络使用最大似然来训练。
这意味着代价函数就是负的对数似然，它与训练数据和模型分布间的交叉熵等价。

> **[success][最大似然估计、对数似然](https://windmising.gitbook.io/mathematics-basic-for-ml/gai-shuai-lun/likelihood)、[交叉熵](https://windmising.gitbook.io/mathematics-basic-for-ml/xin-xi-lun/kl)**    
> **问：为什么说“使用最大似然来训练，就意味着代价函数就是负的对数似然”？**  
> 答：根据链接内容可知，求最大似然估计与求最大对数似然估计是等价的，那么似然估计最大化就是负对数似然的最小化。    
> **问：为什么说“负的对数似然与训练数据和模型分布间的交叉熵等价”?**  
> 答：根据定义知，交叉熵公式与负对数似然公式相同。  

　　  
> **[danger]不要把以上链接中公式中的x与深度学习模型的中输入x混淆。**  
> 以上公式都是概率论与信息论的通用公式，公式中的x只是代表概率模型中的一种随机变量。  
> 当以上这个数学理论结合到深度学习模型中时，通常把模型的条件输出y|x看作是数学理论中的随机变量。  
> 只有当数学理论应用到深度学习的模型中时，x才可以看作是模型的输入，而y是模型的输出。  

这个代价函数表示为  
$$
J(\theta) = -{\Bbb E}_{X,y \sim \hat{p}_\text{data}} \log p_\text{model} (y \mid x)
$$
        （6.12）
{% reveal %}
```
\begin{equation}
J(\theta) = -{\Bbb E}_{X,y \sim \hat{p}_\text{data}} \log p_\text{model} (y \mid x) \tag {6.12}
\end{equation}
```
{% endreveal %}

> **[success]问：公式6.12怎么来的？**  
答：前面说过，使用负的对数似然作为代价函数。负对数似然的公式为：  
$$
-{\Bbb E}_{X,y \sim \hat{p}_\text{data}} \log p_\text{model} (x)
$$

> 其中x为“我们关心的符合某种分布的随机变量”。  
在深度学习模型中，“我们关心的符合某种分布的随机变量”就是模型输出的条件概率y|x。  
把y|x代入负对数似然公式就得到了公式6.12。  

代价函数的具体形式随着模型而改变，取决于$$\log p_\text{model}$$的具体形式。  
> **[success]**与深度学习模型中的输出单元有关。  

上述方程的展开形式通常会有一些项不依赖于模型的参数，我们可以舍去。
例如，正如我们在第5.1.1节中看到的，如果$$p_\text{model}(y\mid x) = N(y;f(x;\theta), I)$$，那么我们就重新得到了均方误差代价，  

> **[info]** 5.1.1 -> 5.5.1

$$
J(\theta) = \frac{1}{2} {\Bbb E}_{X, y \sim  \hat{p}_\text{data}} || y - f(x; \theta) ||^2 + \text{const}
$$
    （6.13）
{% reveal %}
```
\begin{equation}
J(\theta) = \frac{1}{2} {\Bbb E}_{X, y \sim  \hat{p}_\text{data}} || y - f(x; \theta) ||^2 + \text{const} \tag {6.13}
\end{equation}
```
{% endreveal %}

> **[success]问：把$$p_\text{model}(y\mid x)$$代入公式（6.12），怎么会得到（6.13）？**  
答：假设$$p_\text{model}(y\mid x)$$符合高斯分布，且其均值为基于输入x计算出来的某个值，方差为固定值1。  
把高斯分布公式代入6.12，得$$J(\theta) = {\Bbb E}[\log I + \frac{1}{2}\log(2\pi) + \frac{||y - f(x;\theta)||^2}{2\sigma^2}]$$  
这是一个关于$$\theta$$的公式，公式中与$$\theta$$无关的项都可以看作是常数项。  
提取出常数项和公约数就得到了公式6.13。  
> **问：这一节本来在讲交叉熵代价函数，怎么到这里变成均方误差代价了？**  
答：这里并非强调计算的是均方误差代价。  
而是基于最大似然的数学理论，计算出了的$$p_\text{model}(y\mid x)$$的交叉熵代价函数。经过对交叉熵代价函数的化简，最后得到了与均方误差代价函数一样的结果。  
殊途同归的意思。  

至少系数$$\frac{1}{2}$$和常数项不依赖于$$\theta$$。
舍弃的常数是基于高斯分布的方差，在这种情况下我们选择不把它参数化。  
> **[warning]** 不把它参数化是什么意思？  

之前，我们看到了对输出分布的最大似然估计和对线性模型均方误差的最小化之间的等价性，但事实上，这种等价性并不要求$$f(x; \theta)$$用于预测高斯分布的均值。  
> **[warning]** 还适用于什么分面？还是适用于所有分布？如何证明？  

# 优点1：减轻设计代价函数的负担

使用最大似然来导出代价函数的方法的一个优势是，它减轻了为每个模型设计代价函数的负担。
明确一个模型$$p(y\mid x)$$则自动地确定了一个代价函数$$\log p(y\mid x)$$。  
> **[info]** $$\log p(y\mid x)$$ -> $$-\log p(y\mid x)$$

# 优点2：避免激活函数的饱和问题

贯穿神经网络设计的一个反复出现的主题是代价函数的梯度必须足够的大和具有足够的预测性，来为学习算法提供一个好的指引。  
> **[success] 为什么梯度必须足够大？**   
答：梯度下降法的理论依据是：“沿着导数的负方向移动，代价函数就会下降”。  
因此梯度下降法的迭代是靠梯度来引导。当梯度太小时，无法引导算法继续优化。  

　　  
> **[warning]** 什么叫有足够的预测性？  

饱和（变得非常平）的函数破坏了这一目标，因为它们把梯度变得非常小。  
> **[success] 什么是饱和？**  
答：如果某个单元的激活函数对输入不敏感，即无论输入怎么变化，它的输出都不怎么改变，就说这个单元是饱和的。  
当单元的激活函数的导数在输入点上非常小时，会发生这种情况。  

这在很多情况下都会发生，因为用于产生隐藏单元或者输出单元的输出的激活函数会饱和。
负的对数似然帮助我们在很多模型中避免这个问题。
很多输出单元都会包含一个指数函数，这在它的变量取绝对值非常大的负值时会造成饱和。  
> **[success] 举个例子**
例如sigmoid unit，激活函数为$$\sigma(z) = \frac{1}{1+\exp(-z)}$$，它的导数为$$\sigma'(z) = \sigma(z)(1-\sigma(z))$$，那么当|z|非常大时，$$\sigma'(z)$$非常接近0，处于饱和状态。  

负对数似然代价函数中的对数函数消除了某些输出单元中的指数效果。  
> **[success] 继续上面的例子**  
如果使用sigmoid unit，那么  
$$
p_\text{model}(y\mid x)=
\begin{cases}
f(x;\theta) & = & \sigma(x) & , y=1\\
1 - f(x;\theta) & = & 1-\sigma(x) & , y = 0
\end{cases}
$$

> 代入代价函数得：  
$$
J(\theta) = - y\log\sigma(x) - (1-y)(1-\log\sigma(x)) 
$$

> 根据求导链式法则：  
$$
\frac{\partial J}{\partial x} = \sigma(a) - y
$$

> 导数中消除了$$\sigma'(z)$$这一部分，从而避免了饱和问题。  
> [link](https://play-with-handwritten-digits.netlify.com/6-2-1-1-sigmoid-quadratic-crossentropy.html)证明了这一点  

我们将会在第6.2.2节中讨论代价函数和输出单元的选择间的相互作用。

# 特性3：没有最小值

用于实现最大似然估计的交叉熵代价函数有一个不同寻常的特性，那就是当它被应用于实践中经常遇到的模型时，它通常没有最小值。  
> **[warning]** ?

对于离散型输出变量，大多数模型以一种特殊的形式来参数化，即它们不能表示概率零和一，但是可以无限接近。  
> **[success]** 例如输出变量为0、1，sigmoid输出的是(0,1)的某个值。  

逻辑回归是其中一个例子。
对于实值的输出变量，如果模型可以控制输出分布的密度（例如，通过学习高斯输出分布的方差参数），那么它可能对正确的训练集输出赋予极其高的密度，这将导致交叉熵趋向负无穷。  
> **[warning]** ?

第7章中描述的正则化技术提供了一些不同的方法来修正学习问题，使得模型不会通过这种方式来获得无限制的收益。
